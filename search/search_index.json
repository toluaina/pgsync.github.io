{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PGSync \u00b6 Postgres to Elasticsearch sync PGSync is a middleware for syncing data from Postgres to Elasticsearch. It allows you to keep Postgres as your source of truth and expose structured denormalized documents in Elasticsearch. Simply describe your document structure or schema in JSON and PGSync will continuously capture changes in your data and load it into Elasticsearch without writing any code. PGSync transforms your relational data into a structured document format. It allows you to take advantage of the expressive power and scalability of Elasticsearch directly from Postgres. You don\u2019t have to write complex queries and transformation pipelines. PGSync is lightweight, fast and flexible.","title":"PGSync"},{"location":"#pgsync","text":"Postgres to Elasticsearch sync PGSync is a middleware for syncing data from Postgres to Elasticsearch. It allows you to keep Postgres as your source of truth and expose structured denormalized documents in Elasticsearch. Simply describe your document structure or schema in JSON and PGSync will continuously capture changes in your data and load it into Elasticsearch without writing any code. PGSync transforms your relational data into a structured document format. It allows you to take advantage of the expressive power and scalability of Elasticsearch directly from Postgres. You don\u2019t have to write complex queries and transformation pipelines. PGSync is lightweight, fast and flexible.","title":"PGSync"},{"location":"advanced/re-indexing/","text":"Re-indexing involves: Deleting the Elasticsearch index curl -X DELETE <protocol>://<hostname>:<port>/<index> Deleting the checkpoint file. This is a hidden file which is a concatenation of the database name and the index name rm .<database name>_<index name> Then re-run pgsync pgsync -c /path/to/schema.json Info If any new tables were added or removed from the schema, you should re-run bootstrap first.","title":"Re indexing"},{"location":"env-vars/","text":"PGSync uses the dotenv module for reading a .env file. You can declare environment variables in a .env file located at the root of your application. Alternatively, you can set environment variables manually. e.g $ export PG_USER = kermit-the-frog $ export PG_USER = localhost $ export PG_PORT = 5432 $ export PG_PASSWORD = ****** PGSync provides the following environment variables: Environment variable Default Description SCHEMA Path to the application schema config QUERY_CHUNK_SIZE 10000 Database query chunk size (how many records to fetch at a time) POLL_TIMEOUT 0.1 Poll db interval (consider reducing this duration to increase throughput) REPLICATION_SLOT_CLEANUP_INTERVAL 180.0 Replication slot cleanup interval (in secs) ELASTICSEARCH_SCHEME http Elasticsearch protocol ELASTICSEARCH_HOST localhost Elasticsearch host ELASTICSEARCH_PORT 9200 Elasticsearch port ELASTICSEARCH_USER Elasticsearch user ELASTICSEARCH_PASSWORD Elasticsearch password ELASTICSEARCH_TIMEOUT 10 Increase this if you are getting read request timeouts ELASTICSEARCH_CHUNK_SIZE 2000 Elasticsearch index chunk size (how many documents to index at a time) ELASTICSEARCH_MAX_CHUNK_BYTES 104857600 The maximum size of the Elasticsearch request in bytes (default: 100MB) ELASTICSEARCH_THREAD_COUNT 4 The size of the threadpool to use for Elasticsearch bulk requests ELASTICSEARCH_QUEUE_SIZE 4 The size of the task queue between the main thread (producing chunks to send) and the processing threads ELASTICSEARCH_VERIFY_CERTS True Verify Elasticsearch SSL certificates ELASTICSEARCH_USE_SSL False Turn on SSL ELASTICSEARCH_SSL_SHOW_WARN False Show warnings about ssl certs verification ELASTICSEARCH_CA_CERTS Path to CA certs on disk ELASTICSEARCH_CLIENT_CERT PEM formatted SSL client certificate ELASTICSEARCH_CLIENT_KEY PEM formatted SSL client key ELASTICSEARCH_AWS_REGION Elasticsearch AWS Region for fully managed services ELASTICSEARCH_AWS_HOSTED False Elasticsearch fully managed service PG_HOST localhost Postgres database host PG_USER Postgres database username (superuser) PG_PORT 5432 Postgres database port PG_PASSWORD Postgres database user password PG_SSLMODE Postgres SSL TCP/IP connection mode ('disable', 'allow', 'prefer', 'require', 'verify-ca' or 'verify-full') PG_SSLROOTCERT The name of a file containing SSL certificate authority (CA) certificate(s) REDIS_SCHEME redis Redis connection scheme REDIS_HOST localhost Redis server host REDIS_PORT 6379 Redis server port REDIS_DB 0 Redis database REDIS_AUTH Redis password REDIS_CHUNK_SIZE 1000 Number of items to read from Redis at a time REDIS_SOCKET_TIMEOUT 5 Redis socket connection timeout REDIS_POLL_INTERVAL 0.01 Redis poll interval NEW_RELIC_ENVIRONMENT New Relic environment name NEW_RELIC_APP_NAME New Relic application name NEW_RELIC_LOG_LEVEL Sets the level of detail of messages sent to the log file NEW_RELIC_LICENSE_KEY New Relic license key","title":"Environment variables"},{"location":"features/","text":"Features \u00b6 Key features of PGSync include: Works with any PostgreSQL database (version 9.4 or later). Negligible impact on database performance. Transactionally consistent output in Elasticsearch. This means: writes appear only when they are committed to the database, insert, update and delete operations appear in the same order as they were committed (as opposed to eventual consistency). Fault-tolerant: does not lose data, even if processes crash or a network interruption occurs, etc. The process can be recovered from the last checkpoint. Returns the data directly as Postgres JSON from the database for speed. Supports composite primary and foreign keys. Supports an arbitrary depth of nested entities i.e Tables having long chain of relationship dependencies. Supports Postgres JSON data fields. This means: we can extract JSON fields in a database table as a separate field in the resulting document. Customizable document structure.","title":"Features"},{"location":"features/#features","text":"Key features of PGSync include: Works with any PostgreSQL database (version 9.4 or later). Negligible impact on database performance. Transactionally consistent output in Elasticsearch. This means: writes appear only when they are committed to the database, insert, update and delete operations appear in the same order as they were committed (as opposed to eventual consistency). Fault-tolerant: does not lose data, even if processes crash or a network interruption occurs, etc. The process can be recovered from the last checkpoint. Returns the data directly as Postgres JSON from the database for speed. Supports composite primary and foreign keys. Supports an arbitrary depth of nested entities i.e Tables having long chain of relationship dependencies. Supports Postgres JSON data fields. This means: we can extract JSON fields in a database table as a separate field in the resulting document. Customizable document structure.","title":"Features"},{"location":"getting-started/installation/","text":"$ pip install pgsync ---> 100%","title":"Installation"},{"location":"getting-started/running/","text":"First, you need to bootstrap the database. This is a one-time operation that: Creates pgsync triggers Creates the logical replication slot bootstrap --config /path/to/schema.json There are two modes of running PGSync Daemon mode (runs continuously) Non-daemon mode (runs a single pass and stops) Daemon pgsync --config /optional/path/to/schema.json --daemon Non-daemon pgsync --config /optional/path/to/schema.json Info You can also specify the schema config as an environment variable SCHEMA and omit it in the command(s) above. The next section describes how to provide connection parameters via environment variables.","title":"Running"},{"location":"getting-started/setup/","text":"Setup \u00b6 Non-AWS Ensure Postgres database user is a superuser (this is required to query replication slots) SELECT usename FROM pg_user WHERE usesuper = true Enable logical decoding in postgres.conf wal_level = logical Ensure there is at least one replication slot defined in postgres.conf max_replication_slots = 1 AWS Ensure Postgres database user is a superuser GRANT rds_superuser TO <username> Enable logical_replication by using the parameter group settings described here","title":"Setup"},{"location":"getting-started/setup/#setup","text":"Non-AWS Ensure Postgres database user is a superuser (this is required to query replication slots) SELECT usename FROM pg_user WHERE usesuper = true Enable logical decoding in postgres.conf wal_level = logical Ensure there is at least one replication slot defined in postgres.conf max_replication_slots = 1 AWS Ensure Postgres database user is a superuser GRANT rds_superuser TO <username> Enable logical_replication by using the parameter group settings described here","title":"Setup"},{"location":"schema/","text":"Schema definition file [ { \"database\" : \"<Postgres database name>\" , \"index\" : \"<Elasticsearch index name>\" , \"setting\" : \"<Elasticsearch setting>\" , \"plugins\" : [ \"<Plugin A>\" , \"<Plugin B>\" ... ], \"pipeline\" : \"<pipeline>\" , \"routing\" : \"<routing>\" , \"nodes\" : { \"table\" : \"<root table name>\" , \"schema\" : \"<schema name>\" , \"columns\" : [ \"<column 1>\" , \"<column 2>\" , ... ], \"children\" : [ { \"table\" : \"<child table name>\" , \"columns\" : [ \"<column 1>\" , \"<column 2>\" , ... ], \"label\" : \"<document label name>\" , \"relationship\" : { \"variant\" : \"object\" | \"scalar\" , \"type\" : \"one_to_one\" | \"one_to_many\" , \"through_tables\" : [ \"<through table name>\" ] }, \"children\" : [], \"transform\" : { \"rename\" : { \"<old column 1>\" : \"<new column 1>\" , \"<old column 2>\" : \"<new column 2>\" , ... }, \"mapping\" : { \"<new column 1>\" : { \"<data type>\" }, \"<new column 2>\" : { \"<data type>\" }, ... }, \"concat\" : { \"columns\" : [ \"column 1\" , \"column 2\" ... ], \"destination\" : \"<new column 1>\" , \"delimiter\" : \"<char>\" } } }, ... ] } } ] Document and node structure: \u00b6 database \u00b6 This is the database name index \u00b6 An optional Elasticsearch index (defaults to database name) nodes \u00b6 An object node describing the Elasticsearch document setting \u00b6 Elasticsearch setting configuration { \"setting\" : { \"analysis\" : { \"analyzer\" : { \"ngram_analyzer\" : { \"filter\" : [ \"lowercase\" ], \"type\" : \"custom\" , \"tokenizer\" : \"ngram_tokenizer\" } }, \"tokenizer\" : { \"ngram_tokenizer\" : { \"token_chars\" : [ \"letter\" , \"digit\" , \"punctuation\" , \"symbol\" ], \"min_gram\" : \"9\" , \"type\" : \"nGram\" , \"max_gram\" : \"10\" } } } } } table \u00b6 Node table name schema \u00b6 An optional Postgres table schema (defaults to public) label \u00b6 An optional node name in Elasticsearch (defaults to table name) columns \u00b6 An optional list of columns to display. This can be omitted in which case it selects all columns. children \u00b6 An optional list of child nodes if any. This has the same structure as a parent node. relationship \u00b6 Describes the relationship between parent and child. variant \u00b6 variant can be object or scalar object \u00b6 { \"name\" : \"Oxford Press\" , \"id\" : 1 , \"is_active\" : false } scalar \u00b6 [ \"Haruki Murakami\" , \"Philip Gabriel\" ] type \u00b6 type can be one_to_one or one_to_many depending on the relationship type between parent and child through_tables \u00b6 This is the intermediate table that connects the parent to the child transform \u00b6 This allows transforming some node properties. For now, the only operation supported is the rename transform. rename \u00b6 rename a node column \"rename\" : { \"<old column name 1>\" : \"<new column name 1>\" , \"<old column name 2>\" : \"<new column name 2>\" , } mapping \u00b6 Specify Elasticsearch mapping \"mapping\" : { \"book_id\" : { \"type\" : \"long\" }, \"book_isbn\" : { \"type\" : \"long\" , \"fields\" :{ \"ngram\" : { \"type\" : \"text\" , \"analyzer\" : \"ngram_analyzer\" , \"search_analyzer\" : \"ngram_analyzer\" , \"fielddata\" : true } } } } pipeline \u00b6 Optional injest pipeline routing \u00b6 Optional routing field Info Changing the schema effectively changes the structure of the document in Elasticsearch and this requires re-indexing Elasticsearch. See the advanced section on re-indexing on how-to.","title":"Schema definition"},{"location":"schema/#document-and-node-structure","text":"","title":"Document and node structure:"},{"location":"schema/#database","text":"This is the database name","title":"database"},{"location":"schema/#index","text":"An optional Elasticsearch index (defaults to database name)","title":"index"},{"location":"schema/#nodes","text":"An object node describing the Elasticsearch document","title":"nodes"},{"location":"schema/#setting","text":"Elasticsearch setting configuration { \"setting\" : { \"analysis\" : { \"analyzer\" : { \"ngram_analyzer\" : { \"filter\" : [ \"lowercase\" ], \"type\" : \"custom\" , \"tokenizer\" : \"ngram_tokenizer\" } }, \"tokenizer\" : { \"ngram_tokenizer\" : { \"token_chars\" : [ \"letter\" , \"digit\" , \"punctuation\" , \"symbol\" ], \"min_gram\" : \"9\" , \"type\" : \"nGram\" , \"max_gram\" : \"10\" } } } } }","title":"setting"},{"location":"schema/#table","text":"Node table name","title":"table"},{"location":"schema/#schema","text":"An optional Postgres table schema (defaults to public)","title":"schema"},{"location":"schema/#label","text":"An optional node name in Elasticsearch (defaults to table name)","title":"label"},{"location":"schema/#columns","text":"An optional list of columns to display. This can be omitted in which case it selects all columns.","title":"columns"},{"location":"schema/#children","text":"An optional list of child nodes if any. This has the same structure as a parent node.","title":"children"},{"location":"schema/#relationship","text":"Describes the relationship between parent and child.","title":"relationship"},{"location":"schema/#variant","text":"variant can be object or scalar","title":"variant"},{"location":"schema/#object","text":"{ \"name\" : \"Oxford Press\" , \"id\" : 1 , \"is_active\" : false }","title":"object"},{"location":"schema/#scalar","text":"[ \"Haruki Murakami\" , \"Philip Gabriel\" ]","title":"scalar"},{"location":"schema/#type","text":"type can be one_to_one or one_to_many depending on the relationship type between parent and child","title":"type"},{"location":"schema/#through_tables","text":"This is the intermediate table that connects the parent to the child","title":"through_tables"},{"location":"schema/#transform","text":"This allows transforming some node properties. For now, the only operation supported is the rename transform.","title":"transform"},{"location":"schema/#rename","text":"rename a node column \"rename\" : { \"<old column name 1>\" : \"<new column name 1>\" , \"<old column name 2>\" : \"<new column name 2>\" , }","title":"rename"},{"location":"schema/#mapping","text":"Specify Elasticsearch mapping \"mapping\" : { \"book_id\" : { \"type\" : \"long\" }, \"book_isbn\" : { \"type\" : \"long\" , \"fields\" :{ \"ngram\" : { \"type\" : \"text\" , \"analyzer\" : \"ngram_analyzer\" , \"search_analyzer\" : \"ngram_analyzer\" , \"fielddata\" : true } } } }","title":"mapping"},{"location":"schema/#pipeline","text":"Optional injest pipeline","title":"pipeline"},{"location":"schema/#routing","text":"Optional routing field Info Changing the schema effectively changes the structure of the document in Elasticsearch and this requires re-indexing Elasticsearch. See the advanced section on re-indexing on how-to.","title":"routing"},{"location":"tutorial/json-fields/","text":"PGSync supports Postgres JSON and JSONB operators. This allows you to extract data within JSON fields. These operators are defined here For example. Given a Postgres JSON field called doc { \"a\" : { \"b\" : { \"c\" : [ 0 , 1 , 2 , 3 , 4 ] } }, \"x\" : [ { \"y\" : 0 , \"z\" : 5 }, { \"y\" : 1 , \"z\" : 6 } ] } We can define this JSON schema to extract the fourth element of the {a, b, c} path, we can define this schema [ { \"database\" : \"book\" , \"index\" : \"book\" , \"nodes\" : { \"table\" : \"book\" , \"schema\" : \"my_book_library\" , \"columns\" : [ \"doc#>{a,b,c}->4\" ] } } ] We can define this JSON schema, to get the first array element of field x . [ { \"database\" : \"book\" , \"index\" : \"book\" , \"nodes\" : { \"table\" : \"book\" , \"schema\" : \"my_book_library\" , \"columns\" : [ \"doc->x->0\" ] } } ] Info doc is the field name in the database","title":"Json fields"},{"location":"tutorial/multiple-schemas-in-single-config/","text":"We can declare multiple schemas in the same config. This can be useful for syncing multiple tables into different Elasticsearch indices. [ { \"database\" : \"book\" , \"index\" : \"book_index\" , \"nodes\" : { \"table\" : \"book\" } }, { \"database\" : \"book\" , \"index\" : \"author_index\" , \"nodes\" : { \"table\" : \"author\" } } ]","title":"Multiple schemas in single config"},{"location":"tutorial/plugins/","text":"Plugins allow you to alter a document right before indexing. This can be useful for applying transformations to documents and offers greater flexibility. Although this comes with some level of development. Plugins are currently supported only in the Python Language. For example, imagine you had a user profile database with firstname and lastname fields and generating the Elasticsearch doc below. { \"firstname\" : \"feng\" , \"lastname\" : \"shui\" } we can create a plugin to add a fullname field to the document right before indexing. Create a \"plugins\" directory and add it to your PYTHONPATH . Create a plugin module - fullnameplugin.py inside the \"plugins\" directory and add the code below: class FullnamePlugin(plugin.Plugin): name = 'Fullname' def transform(self, doc, **kwargs): firstname = doc['firstname'] lastname = doc['lastname'] doc['fullname'] = f'{firstname}{lastname}' return doc Then simply activate the plugin by adding it to the list of plugins in the schema.json [ { \"database\" : \"users\" , \"index\" : \"users\" , \"plugins\" : [ \"Fullname\" ], \"nodes\" : { \"table\" : \"profile\" } } ] To get this document in Elasticsearch { \"firstname\" : \"feng\" , \"lastname\" : \"shui\" , \"fullname\" : \"feng shui\" } Info Plugin names are case sensitive","title":"Plugins"},{"location":"tutorial/relationship-with-object-variant/","text":"Each child node can have only one direct parent. You can specify the relationship between a parent and child node with the relationship property. [ { \"database\" : \"book\" , \"index\" : \"book\" , \"nodes\" : { \"table\" : \"book\" , \"children\" : [ { \"table\" : \"author\" , \"columns\" : [ \"id\" , \"name\" ], \"relationship\" : { \"variant\" : \"object\" , \"type\" : \"one_to_one\" }, } ] } } ] To get this document structure in Elasticsearch [ { \"isbn\" : \"9785811243570\" , \"title\" : \"Charlie and the chocolate factory\" , \"publisher\" : { \"id\" : 1 , \"name\" : \"Oxford Press\" } }, { \"isbn\" : \"9788374950978\" , \"title\" : \"Kafka on the Shore\" , \"publisher\" : { \"id\" : 2 , \"name\" : \"Penguin Books\" } }, { \"isbn\" : \"9781471331435\" , \"title\" : \"1984\" , \"publisher\" : { \"id\" : 3 , \"name\" : \"Pearson Press\" } } ] Info A relationship must include both a variant and a type attribute","title":"Relationship with object variant"},{"location":"tutorial/relationship-with-one-to-many-type/","text":"Each child node can have only one direct parent. We can specify the relationship between a parent and child node with the relationship property. [ { \"database\" : \"book\" , \"index\" : \"book\" , \"nodes\" : { \"table\" : \"book\" , \"children\" : [ { \"table\" : \"author\" , \"columns\" : [ \"id\" , \"name\" ], \"relationship\" : { \"variant\" : \"object\" , \"type\" : \"one_to_many\" }, } ] } } ] To get this document structure in Elasticsearch [ { \"isbn\" : \"9785811243570\" , \"title\" : \"Charlie and the chocolate factory\" , \"publisher\" : [ { \"id\" : 1 , \"name\" : \"Oxford Press\" } ] }, { \"isbn\" : \"9788374950978\" , \"title\" : \"Kafka on the Shore\" , \"publisher\" : [ { \"id\" : 2 , \"name\" : \"Penguin Books\" } ] }, { \"isbn\" : \"9781471331435\" , \"title\" : \"1984\" , \"publisher\" : [ { \"id\" : 3 , \"name\" : \"Pearson Press\" } ] } ] Info A relationship must include both a variant and a type attribute","title":"Relationship with one to many type"},{"location":"tutorial/relationship-with-one-to-one-type/","text":"Each child node can have only one direct parent. We can specify the relationship between a parent and child node with the relationship property. [ { \"database\" : \"book\" , \"index\" : \"book\" , \"nodes\" : { \"table\" : \"book\" , \"children\" : [ { \"table\" : \"author\" , \"columns\" : [ \"id\" , \"name\" ], \"relationship\" : { \"variant\" : \"object\" , \"type\" : \"one_to_one\" }, } ] } } ] To get this document structure in Elasticsearch [ { \"isbn\" : \"9785811243570\" , \"title\" : \"Charlie and the chocolate factory\" , \"publisher\" : { \"id\" : 1 , \"name\" : \"Oxford Press\" } }, { \"isbn\" : \"9788374950978\" , \"title\" : \"Kafka on the Shore\" , \"publisher\" : { \"id\" : 2 , \"name\" : \"Penguin Books\" } }, { \"isbn\" : \"9781471331435\" , \"title\" : \"1984\" , \"publisher\" : { \"id\" : 3 , \"name\" : \"Pearson Press\" } } ] Info A relationship must include both a variant and a type attribute","title":"Relationship with one to one type"},{"location":"tutorial/relationship-with-scalar-variant/","text":"Each child node can have only one direct parent. You can specify the relationship between a parent and child node with the relationship property. [ { \"database\" : \"book\" , \"index\" : \"book\" , \"nodes\" : { \"table\" : \"book\" , \"children\" : [ { \"table\" : \"author\" , \"columns\" : [ \"name\" ], \"relationship\" : { \"variant\" : \"scalar\" , \"type\" : \"one_to_one\" }, } ] } } ] To get this document structure in Elasticsearch [ { \"isbn\" : \"9785811243570\" , \"title\" : \"Charlie and the chocolate factory\" , \"publisher\" : \"Oxford Press\" }, { \"isbn\" : \"9788374950978\" , \"title\" : \"Kafka on the Shore\" , \"publisher\" : \"Penguin Books\" }, { \"isbn\" : \"9781471331435\" , \"title\" : \"1984\" , \"publisher\" : \"Pearson Press\" } ] Info A relationship must include both a variant and a type attribute","title":"Relationship with scalar variant"},{"location":"tutorial/relationship-with-through-tables/","text":"Each child node can have only one direct parent. We can specify the relationship between a parent and child node with the relationship property. [ { \"database\" : \"book\" , \"index\" : \"book\" , \"nodes\" : { \"table\" : \"book\" , \"columns\" : [ \"isbn\" , \"title\" , \"description\" ], \"children\" : [ { \"table\" : \"author\" , \"columns\" : [ \"id\" , \"name\" ], \"relationship\" : { \"type\" : \"one_to_many\" , \"variant\" : \"object\" , \"through_tables\" : [ \"book_author\" ] } } ] } } ] To get this document structure in Elasticsearch [ { \"isbn\" : \"9785811243570\" , \"title\" : \"Charlie and the chocolate factory\" , \"author\" : [ { \"id\" : 1 , \"name\" : \"Roald Dahl\" } ] }, { \"isbn\" : \"9788374950978\" , \"title\" : \"Kafka on the Shore\" , \"author\" : [ { \"id\" : 2 , \"name\" : \"Haruki Murakami\" }, { \"id\" : 3 , \"name\" : \"Philip Gabriel\" } ] }, { \"isbn\" : \"9781471331435\" , \"title\" : \"1984\" , \"author\" : [ { \"id\" : 4 , \"name\" : \"George Orwell\" } ] } ] Info A relationship must include both a variant and a type attribute","title":"Relationship with through tables"},{"location":"tutorial/relationship-with-user-defined-foreign-key/","text":"You can specify the relationship foreign key as a property on the relationship . [ { \"database\" : \"book\" , \"index\" : \"book\" , \"nodes\" : { \"table\" : \"book\" , \"children\" : [ { \"table\" : \"author\" , \"columns\" : [ \"id\" , \"name\" ], \"relationship\" : { \"variant\" : \"object\" , \"type\" : \"one_to_one\" , \"foreign_key\" : { \"child\" : [ \"id\" ], \"parent\" : [ \"parent_id\" ] } }, } ] } } ]","title":"Relationship with user defined foreign key"},{"location":"tutorial/selecting-schema/","text":"Postgres supports having multiple schemas in the same database. You can select an alternative schema using the node schema attribute. The default schema is the public schema. [ { \"database\" : \"book\" , \"index\" : \"book\" , \"nodes\" : { \"table\" : \"book\" , \"schema\" : \"my_book_library\" , \"columns\" : [ \"isbn\" , \"title\" ] } } ]","title":"Selecting schema"},{"location":"tutorial/table-with-multiple-children/","text":"What if we added a new table publisher Publisher id (PK) name 1 Oxford Press 2 Penguin Books 3 Pearson Press and we added publisher_id as a foreign key to the Book table: Book isbn (PK) title description publisher_id (FK) 9785811243570 Charlie and the chocolate factory Willy Wonka\u2019s famous chocolate factory is opening at last! 1 9788374950978 Kafka on the Shore Kafka on the Shore is a 2002 novel by Japanese author Haruki Murakami. 2 9781471331435 1984 1984 was George Orwell\u2019s chilling prophecy about the dystopian future. 3 We can simply define this JSON schema where the book table is still the pivot table. [ { \"database\" : \"book\" , \"index\" : \"book\" , \"nodes\" : { \"table\" : \"book\" , \"columns\" : [ \"isbn\" , \"title\" , \"description\" ], \"children\" : [ { \"table\" : \"author\" , \"columns\" : [ \"name\" ] }, { \"table\" : \"publisher\" , \"columns\" : [ \"name\" , \"id\" ] } ] } } ] To get this document structure in Elasticsearch [ { \"isbn\" : \"9785811243570\" , \"title\" : \"Charlie and the chocolate factory\" , \"description\" : \"Willy Wonka\u2019s famous chocolate factory is opening at last!\" , \"author\" : [ \"Roald Dahl\" ], \"publisher\" : \"Oxford Press\" }, { \"isbn\" : \"9788374950978\" , \"title\" : \"Kafka on the Shore\" , \"description\" : \"Kafka on the Shore is a 2002 novel by Japanese author Haruki Murakami\" , \"author\" : [ \"Haruki Murakami\" , \"Philip Gabriel\" ], \"publisher\" : \"Penguin Books\" }, { \"isbn\" : \"9781471331435\" , \"title\" : \"1984\" , \"description\" : \"1984 was George Orwell\u2019s chilling prophecy about the dystopian future\" , \"author\" : [ \"George Orwell\" ], \"publisher\" : \"Pearson Press\" } ]","title":"Table with multiple children"},{"location":"tutorial/table-with-single-child-node/","text":"Consider this example of a Book library database. Book isbn (PK) title description 9785811243570 Charlie and the chocolate factory Willy Wonka\u2019s famous chocolate factory is opening at last! 9788374950978 Kafka on the Shore Kafka on the Shore is a 2002 novel by Japanese author Haruki Murakami. 9781471331435 1984 1984 was George Orwell\u2019s chilling prophecy about the dystopian future. Author id (PK) name 1 Roald Dahl 2 Haruki Murakami 3 Philip Gabriel 4 George Orwell BookAuthor id (PK) book_isbn (FK) author_id (FK) 1 9785811243570 1 2 9788374950978 2 3 9788374950978 3 4 9781471331435 4 With PGSync, we can simply define this JSON schema where the book table is the pivot. A pivot table indicates the root of your document. { \"table\" : \"book\" , \"columns\" : [ \"isbn\" , \"title\" , \"description\" ], \"children\" : [ { \"table\" : \"author\" , \"columns\" : [ \"name\" ] } ] } To get this document structure in Elasticsearch [ { \"isbn\" : \"9785811243570\" , \"title\" : \"Charlie and the chocolate factory\" , \"description\" : \"Willy Wonka\u2019s famous chocolate factory is opening at last!\" , \"author\" : [ \"Roald Dahl\" ] }, { \"isbn\" : \"9788374950978\" , \"title\" : \"Kafka on the Shore\" , \"description\" : \"Kafka on the Shore is a 2002 novel by Japanese author Haruki Murakami\" , \"author\" : [ \"Haruki Murakami\" , \"Philip Gabriel\" ] }, { \"isbn\" : \"9781471331435\" , \"title\" : \"1984\" , \"description\" : \"1984 was George Orwell\u2019s chilling prophecy about the dystopian future\" , \"author\" : [ \"George Orwell\" ] } ] Behind the scenes, PGSync is generating advanced queries for you such as. SELECT JSON_BUILD_OBJECT ( 'isbn' , book_1 . isbn , 'title' , book_1 . title , 'description' , book_1 . description , 'authors' , anon_1 . authors ) AS \"JSON_BUILD_OBJECT_1\" , book_1 . id FROM book AS book_1 LEFT OUTER JOIN ( SELECT JSON_AGG ( anon_2 . anon ) AS authors , book_author_1 . book_isbn AS book_isbn FROM book_author AS book_author_1 LEFT OUTER JOIN ( SELECT author_1 . name AS anon , author_1 . id AS id FROM author AS author_1 ) AS anon_2 ON anon_2 . id = book_author_1 . author_id GROUP BY book_author_1 . book_isbn ) AS anon_1 ON anon_1 . book_isbn = book_1 . isbn","title":"Table with single child node"},{"location":"tutorial/transform-nodes/","text":"Transform nodes allow you to change the output of the document type rename \u00b6 We can simply define this JSON schema. [ { \"database\" : \"book\" , \"index\" : \"book\" , \"nodes\" : { \"table\" : \"book\" , \"columns\" : [ \"isbn\" , \"title\" ], \"transform\" : { \"rename\" : { \"isbn\" : \"book_isbn\" , \"title\" : \"book_title\" } } } } ] To get this document structure in Elasticsearch [ { \"book_isbn\" : \"9785811243570\" , \"book_title\" : \"Charlie and the chocolate factory\" }, { \"book_isbn\" : \"9788374950978\" , \"book_title\" : \"Kafka on the Shore\" }, { \"book_isbn\" : \"9781471331435\" , \"book_title\" : \"1984\" } ] mapping \u00b6 You can specify the data type for an Elasticsearch field in the schema. You can find the list of supported data types here [ { \"database\" : \"book\" , \"index\" : \"book\" , \"node\" : { \"table\" : \"book\" , \"columns\" : [ \"isbn\" , \"title\" ], \"transform\" : { \"mapping\" : { \"isbn\" : \"long\" , \"title\" : \"keyword\" } } } } ] concat \u00b6 You can concatenate multiple columns into a single field with an optional delimiter. [ { \"database\" : \"book\" , \"index\" : \"book\" , \"node\" : { \"table\" : \"book\" , \"columns\" : [ \"title\" , \"firstname\" , \"lastname\" ], \"transform\" : { \"concat\" : { \"columns\" : [ \"title\" , \"firstname\" , \"lastname\" ], \"destination\" : \"fullname\" , \"delimiter\" : \"-\" } } } } ]","title":"Transform nodes"},{"location":"tutorial/transform-nodes/#rename","text":"We can simply define this JSON schema. [ { \"database\" : \"book\" , \"index\" : \"book\" , \"nodes\" : { \"table\" : \"book\" , \"columns\" : [ \"isbn\" , \"title\" ], \"transform\" : { \"rename\" : { \"isbn\" : \"book_isbn\" , \"title\" : \"book_title\" } } } } ] To get this document structure in Elasticsearch [ { \"book_isbn\" : \"9785811243570\" , \"book_title\" : \"Charlie and the chocolate factory\" }, { \"book_isbn\" : \"9788374950978\" , \"book_title\" : \"Kafka on the Shore\" }, { \"book_isbn\" : \"9781471331435\" , \"book_title\" : \"1984\" } ]","title":"rename"},{"location":"tutorial/transform-nodes/#mapping","text":"You can specify the data type for an Elasticsearch field in the schema. You can find the list of supported data types here [ { \"database\" : \"book\" , \"index\" : \"book\" , \"node\" : { \"table\" : \"book\" , \"columns\" : [ \"isbn\" , \"title\" ], \"transform\" : { \"mapping\" : { \"isbn\" : \"long\" , \"title\" : \"keyword\" } } } } ]","title":"mapping"},{"location":"tutorial/transform-nodes/#concat","text":"You can concatenate multiple columns into a single field with an optional delimiter. [ { \"database\" : \"book\" , \"index\" : \"book\" , \"node\" : { \"table\" : \"book\" , \"columns\" : [ \"title\" , \"firstname\" , \"lastname\" ], \"transform\" : { \"concat\" : { \"columns\" : [ \"title\" , \"firstname\" , \"lastname\" ], \"destination\" : \"fullname\" , \"delimiter\" : \"-\" } } } } ]","title":"concat"},{"location":"tutorial/using-labels/","text":"Labels are used to control the output of the document node. We can simply define this JSON schema. [ { \"database\" : \"book\" , \"index\" : \"book\" , \"nodes\" : { \"table\" : \"book\" , \"columns\" : [ \"isbn\" , \"title\" ], \"children\" : [ { \"table\" : \"author\" , \"label\" : \"authors\" , \"columns\" : [ \"name\" ] } ] } } ] To get this document structure in Elasticsearch [ { \"isbn\" : \"9785811243570\" , \"title\" : \"Charlie and the chocolate factory\" , \"authors\" : [ \"Roald Dahl\" ] }, { \"isbn\" : \"9788374950978\" , \"title\" : \"Kafka on the Shore\" , \"authors\" : [ \"Haruki Murakami\" , \"Philip Gabriel\" ] }, { \"isbn\" : \"9781471331435\" , \"title\" : \"1984\" , \"authors\" : [ \"George Orwell\" ] } ]","title":"Using labels"}]}